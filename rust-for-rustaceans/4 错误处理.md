对于除了最简单的程序之外的所有程序，您都会有可能失败的方法。在本章中，我们将研究表示、处理和传播这些故障的不同方法以及每种方法的优缺点。我们将首先探索表示错误的不同方法，包括枚举和擦除，然后检查一些需要不同表示技术的特殊错误情况。接下来，我们将了解处理错误的各种方法以及错误处理的未来。

值得注意的是，Rust 中错误处理的最佳实践仍然是一个活跃的话题，在撰写本文时，生态系统尚未确定一个单一的、统一的方法。因此，本章将重点关注基本原理和技术，而不是推荐特定的包或模式。

**Representing Errors** 

当您编写可能失败的代码时，要问自己的最重要的问题是您的用户将如何与返回的任何错误进行交互。用户是否需要确切地知道发生了哪个错误以及发生了什么问题的细节，或者他们只是简单地记录发生了错误并尽可能地继续前进？为了理解这一点，我们必须看看错误的性质是否可能影响调用者收到错误后执行的操作。这反过来将决定我们如何表示不同的错误。

您有两个主要选项来表示错误：枚举和擦除。也就是说，您可以让错误类型*枚举*可能的错误条件，以便调用者可以区分它们，或者您可以只向调用者提供单个*不透明*错误。让我们依次讨论这两个选项。

**Enumeration** 

对于我们的示例，我们将使用一个库函数将字节从某个输入流复制到某个输出流中，就像 std::io::copy 一样。用户为您提供两个流，一个用于读取，一个用于写入，然后您将字节从一个流复制到另一个流。在此过程中，任何一个流都完全有可能失败，此时复制必须停止并向用户返回错误。在这里，用户可能想知道失败的是输入流还是输出流。例如，在 Web 服务器中，如果在将文件流式传输到客户端时输入流发生错误，则可能是因为磁盘被弹出，而如果输出流发生错误，则可能是客户端刚刚断开连接。后者可能是服务器应该忽略的错误，因为到新连接的复制仍然可以完成，而前者可能需要关闭整个服务器！

在这种情况下，我们想要枚举错误。用户需要能够区分不同的错误情况，以便能够做出适当的响应，因此我们使用一个名为 CopyError 的枚举，每个变体代表错误的一个单独的根本原因，如清单 4-1 所示。

```
 pub enum CopyError {
   In(std::io::Error),
   Out(std::io::Error),
 }
```

*Listing 4-1: An enumerated error type*

每个变体还包括遇到的错误，以便为调用者提供尽可能多的有关出错的信息。

在创建自己的错误类型时，您需要采取许多步骤来使错误类型与 Rust 生态系统的其他部分很好地配合。首先，您的错误类型应该实现 std::error::Error 特征，它为调用者提供用于内省错误类型的通用方法。我们感兴趣的主要方法是 Error::source，它提供了一种查找错误根本原因的机制。这最常用于打印回溯，该回溯显示一直追溯到错误根本原因的跟踪。对于我们的 CopyError 类型，source 的实现很简单：我们匹配 self 并提取并返回内部 std::io::Error。

其次，您的类型应该同时实现“显示”和“调试”，以便调用者可以有意义地打印您的错误。如果您实现 Error 特征，则这是必需的。一般来说，您的 Display 实现应该对出现的问题给出一行描述，并且可以轻松地将其折叠到其他错误消息中。显示格式应该是小写并且没有尾随标点符号，以便它可以很好地适应其他较大的错误报告。调试应该提供更具描述性的错误，包括可能有助于追踪错误原因的辅助信息，例如端口号、请求标识符、文件路径等，#[derive(Debug)] 通常就足够了。

**NOTE** * In older Rust code, you may see references to the* *Error::description* *method, but this has been deprecated in favor of* *Display**.* 

第三，如果可能的话，您的类型应该同时实现发送和同步，以便用户能够跨线程边界共享错误。如果您的错误类型不是线程安全的，您会发现几乎不可能在多线程上下文中使用您的包。实现 Send 和 Sync 的错误类型也更容易与非常常见的 std::io::Error 类型一起使用，该类型能够包装实现 Error、Send 和 Sync 的错误。当然，并非所有错误类型都可以合理地进行发送和同步，例如如果它们与特定的线程本地资源相关联，那没关系。您可能也不会跨线程边界发送这些错误。但是，在将 Rc<String> 和 RefCell<bool> 类型放入错误中之前需要注意这一点。

最后，在可能的情况下，您的错误类型应该是“静态”。这样做最直接的好处是，它允许调用者更轻松地在调用堆栈中传播错误，而不会遇到生命周期问题。它还使您的错误类型能够更轻松地与类型擦除的错误类型一起使用，我们很快就会看到。

**Opaque Errors** 

现在让我们考虑一个不同的例子：图像解码库。您为库提供了一堆字节来解码，它使您可以访问各种图像操作方法。如果解码失败，用户需要能够找出解决问题的方法，因此必须了解原因。但是，到底是图像头中的大小字段无效，还是压缩算法无法解压缩块，这重要吗？可能不会——即使应用程序知道确切的原因，也无法从这两种情况中有意义地恢复。在这种情况下，作为库作者的您可能希望提供单一的、不透明的错误类型。这也使您的库更易于使用，因为到处都只使用一种错误类型。此错误类型应实现 Send、Debug、Display 和 Error（包括适当的源方法），但除此之外，调用者不需要了解更多信息。您可以在内部表示更细粒度的错误状态，但无需将这些状态公开给库的用户。这样做只会不必要地增加 API 的大小和复杂性。

您的不透明错误类型到底应该是什么主要取决于您。它可能只是一个具有所有私有字段的类型，仅公开用于显示和自省错误的有限方法，或者它可能是一个严重类型擦除的错误类型，如 Box<dyn Error + Send + Sync + 'static>，它不显示任何内容更重要的是，它是一个错误，并且通常根本不会让您的用户进行内省。决定错误类型的不透明程度主要取决于错误是否有超出其描述的有趣内容。使用 Box<dyn Error>，您的用户除了冒泡错误之外别无选择。如果它确实没有任何有价值的信息可以呈现给用户，那么这可能没问题——例如，如果它只是一条动态错误消息，或者是来自程序内部的大量不相关错误之一。但是，如果错误有一些有趣的方面，例如行号或状态代码，您可能希望通过具体但不透明的类型来公开它。

**N O T E***总的来说，社区的共识是错误应该很少，因此不应该给“幸福之路”增加太多成本。因此，错误通常位于指针类型后面，例如 * *Box* * 或 * *Arc**。这样，它们就不太可能增加太多的总体* *结果* *它们所包含的类型的大小。*

使用类型擦除错误的好处之一是，它允许您轻松组合来自不同来源的错误，而无需引入其他错误类型。也就是说，类型擦除的错误通常可以很好地“组合”，并允许您表达一组开放式错误。如果您编写一个返回类型为 Box<dyn Error + ...> 的函数，那么您可以使用 ?跨该函数内的不同错误类型，针对各种不同的错误，它们都将转换为一种常见的错误类型。

The 'static bound on Box<dyn Error + Send + Sync + 'static> 在删除方面值得花更多时间。我在上一节中提到，它对于让调用者传播错误而不用担心失败方法的生命周期界限很有用，但它有一个更大的目的：访问向下转型。 *向下转型*是将一种类型的项目转换为更具体类型的过程。这是 Rust 允许您在运行时访问类型信息的少数情况之一；这是动态语言通常提供的更通用类型反射的有限情况。在错误的上下文中，当 dyn 错误最初属于该类型时，向下转换允许用户将 dyn 错误转换为具体的底层错误类型。例如，如果用户收到的错误是 std::io::Error 类型的 std::io::ErrorKind ::WouldBlock，则用户可能希望采取特定操作，但他们不会在任何其他情况下采取相同的操作案件。如果用户收到 dyn 错误，他们可以使用 Error::downcast_ref 尝试将错误向下转换为 std::io::Error。 downcast_ref 方法返回一个 Option，它告诉用户向下转换是否成功。这是关键的观察： downcast_ref 仅当参数为“静态”时才有效。如果我们返回一个非“静态”的不透明错误，我们就会剥夺用户进行此类错误自省的能力（如果他们愿意的话）。

对于库的类型擦除错误（或者更一般地说，其类型擦除类型）是否是其公共且稳定的 API 的一部分，生态系统中存在一些分歧。也就是说，如果库中的方法 foo 将 lib::MyError 作为 Box<dyn Error> 返回，那么更改 foo 以返回不同的错误类型是否会是重大更改？类型签名没有改变，但用户可能编写了代码，假设他们可以使用向下转型将该错误转回 lib::MyError。我对此事的看法是，您选择返回 Box<dyn Error> （而不是 lib::MyError）是有原因的，除非明确记录，否则不能保证有关向下转换的任何特定内容。

*虽然* *Box* *是一种有吸引力的类型擦除错误类型，但与直觉相反，它本身并不实现* *Error**。因此，请考虑添加您自己的* *BoxError* *类型，以便在*实现* *Error**的库中进行类型擦除。*

您可能想知道 Error::downcast_ref 如何是安全的。也就是说，它如何知道提供的 dyn Error 参数是否确实属于给定类型 T？标准库甚至有一个名为 Any 的特征，它是为 *any* 类型实现的，并且为 dyn Any 实现了 downcast_ref ——这怎么可能呢？答案在于编译器支持的类型 std::any::TypeId，它允许您获取任何类型的唯一标识符。 Error 特征有一个隐藏的提供方法，称为 type_id，其默认实现是返回 TypeId::of::<Self>()。类似地，Any 有一个针对 T 的 impl Any 的全面实现，并且在该实现中，其 type_id 返回相同的值。在这些 impl 块的上下文中，Self 的具体类型是已知的，因此这个 type_id 是真实类型的类型标识符。这提供了 downcast_ref 所需的所有信息。 downcast_ref 调用 self.type_id，它通过动态大小类型的 vtable（参见第 2 章）转发到底层类型的实现，并将其与提供的向下转型类型的类型标识符进行比较。如果它们匹配，则 dyn Error 或 dyn Any 背后的类型实际上是 T，并且从对一个的引用转换为对另一个的引用是安全的。

**Special Error Cases** 

某些函数容易出错，但如果失败，则无法返回任何有意义的错误。从概念上讲，这些函数的返回类型为 Result<T, ()>。在某些代码库中，您可能会看到它表示为 Option<T>。虽然两者都是此类函数返回类型的合法选择，但它们传达了不同的语义含义，并且通常应避免将 Result<T, ()> “简化”为 Option<T>。Err(()) 指示操作失败，应重试、报告或以其他方式异常处理。另一方面，None 仅传达函数没有要返回的内容;它通常不被视为特殊情况或应该处理的事情。您可以在 Result 类型的 #[must_use] 注释中看到这一点 - 当您获得结果时，语言期望处理这两种情况都很重要，而对于 Option，实际上这两种情况都不需要处理。

**NOTE** *You should also keep in mind that* *()* *does not implement the* *Error* *trait. This means that it cannot be type-erased into* *Box* *and can be a bit of a pain to use with* *?**. For this reason, it is often better to define your own unit struct type, implement* *Error* *for it, and use that as the error instead of* *()* *in these cases.* 

有些函数，比如那些启动连续运行的服务器循环的函数，只返回错误； 除非发生错误，否则它们将永远运行。 其他函数永远不会出错，但仍然需要返回 Result，例如，为了匹配特征签名。 对于这样的函数，Rust 提供了 *never type*，用 ! 编写。 句法。 never 类型表示永远无法生成的值。 您无法自己构造这种类型的实例 - 制作实例的唯一方法是进入无限循环或恐慌，或者通过编译器知道永远不会返回的一些其他特殊操作。 使用 Result，当您知道永远不会使用 Ok 或 Err 时，您可以将其设置为 ! 类型。 如果您编写一个返回 Result<T, !> 的函数，您将无法返回 Err，因为这样做的唯一方法是输入永远不会返回的代码。 因为编译器知道任何带有 ! 的变体 永远不会生成，它还可以考虑到这一点来优化您的代码，例如不为 Result<T, !> 上的展开生成恐慌代码。 当您进行模式匹配时，编译器知道任何包含 ! 的变体。 甚至不需要列出。 很简约！

最后一个奇怪的错误情况是错误类型 std::thread::Result。 这是它的定义：

``` rust
type Result<T> = Result<T, Box<dyn Any + Send + 'static>>;
```

错误类型被类型擦除，但它并没有像我们到目前为止看到的那样被擦除为 dyn Error。 相反，它是一个 dyn Any，它仅保证错误是 *some* 类型，仅此而已。 。 。 这根本不是一个保证。 出现这种奇怪的错误类型的原因是 std::thread::Result 的错误变体仅在响应恐慌时产生； 具体来说，如果您尝试加入一个已经发生恐慌的线程。 在这种情况下，除了忽略错误或使用 unwrap 本身发生恐慌之外，尚不清楚加入线程可以做很多事情。 本质上，错误类型是“恐慌”，值是“传递给恐慌的任何参数！”，它实际上可以是任何类型（即使它通常是格式化字符串）。

Rust的 ? 运算符充当*展开或提前返回*的简写，以便轻松处理错误。 但它还有一些其他值得了解的技巧。 第一的， ? 通过 From 特征执行类型转换。 在返回 Result<T, E> 的函数中，您可以使用 ? 在任何 Result<T, X> 上，其中 E: From<X>。 这个功能使得通过 Box<dyn Error> 进行错误擦除变得如此有吸引力； 你可以只使用？ 无处不在，不用担心特定的错误类型，它通常会“正常工作”。

> **FROM AND INTO** 
> 
> 标准库有许多转换特征，但其中两个核心是 From 和 Into 。 有两个可能会让您觉得奇怪：如果我们有 From，为什么我们需要 Into，反之亦然？ 有几个原因，但让我们从历史原因开始：由于第 2 章中讨论的一致性规则，在 Rust 早期不可能只有一个。 或者，更具体地说，一致性规则曾经是什么。
> 
> 假设您想要在 crate 中定义的某些本地类型和标准库中的某些类型之间实现双向转换。 您可以轻松地为 MyType<T> 编写 impl<T> From<Vec<T>> ，为 MyType<T> 编写 impl<T> Into<Vec<T>> ，但是如果您只有 From 或 Into，那么您将 必须为 Vec<T> 编写 impl<T> From<MyType<T>> 或为 Vec<T> 编写 impl<T> Into<MyType<T>> 。 然而，编译器过去常常拒绝这些实现！ 仅从 Rust 1.41.0 开始，当覆盖类型的例外被添加到一致性规则中时，它们才合法。 在改变之前，这两种特质都必须具备。 由于许多 Rust 代码是在 Rust 1.41.0 之前编写的，因此现在这两个特征都无法删除。
> 
> 然而，除了历史事实之外，即使我们今天可以从头开始，也有充分的人体工程学理由来拥有这两个特征。 在不同情况下使用其中一种通常要容易得多。 例如，如果您正在编写一个采用可转换为 Foo 的类型的方法，您愿意编写 fn(impl Into<Foo>) 还是 fn<T>(T) where Foo: From<T>？ 相反，要将字符串转换为语法标识符，您愿意将 Ident::from("foo") 或 <_ as Into<Ident>>::into("foo") 吗？ 这两个特征都有其用途，我们最好同时拥有它们。
> 
> 鉴于我们确实两者都有，您可能想知道今天应该在代码中使用哪一个。 事实证明，答案非常简单：实现 From 并在bounds 中使用 Into 。 原因是 Into 对任何实现 From 的 T 有一个全面的实现，因此无论类型是否显式实现 From 或 Into，它都会实现 Into！
> 
> 当然，虽然简单的事情经常发生，但故事并没有就此结束。 由于当 Into 用作边界时，编译器通常必须“遍历”总体实现，因此类型是否实现 Into 的推理比它是否实现 From 更复杂。 在某些情况下，编译器不够聪明，无法解决这个难题。 出于这个原因，？ 在撰写本文时，运算符使用 From 而不是 Into 。 大多数时候这没有什么区别，因为大多数类型都实现 From，但这确实意味着来自实现 Into 的旧库的错误类型可能无法与 ? 。 随着编译器变得更加智能，？ 很可能会“升级”为使用 Into，此时问题就会消失，但这就是我们现在所拥有的。


第二个方面？ 需要注意的是，这个运算符实际上只是暂时称为 Try 的特征的语法糖。 在撰写本文时，Try 特征尚未稳定，但当您阅读本文时，它或非常类似的东西很可能已经确定。 由于尚未弄清楚所有细节，我将仅向您提供 Try 工作原理的概述，而不是完整的方法签名。 从本质上讲，Try 定义了一种包装类型，其状态要么是进一步计算有用的状态（快乐路径），要么是无用的状态。 你们中的一些人会正确地想到单子，尽管我们不会在这里探讨这种联系。 例如，在 Result<T, E> 的情况下，如果您有 Ok(t)，则可以通过展开 t 继续走上愉快的道路。 另一方面，如果您有 Err(e)，您希望停止执行并立即生成错误值，因为由于没有 t，所以无法进行进一步计算。

Try 的有趣之处在于它不仅适用于 Result，还适用于更多类型。 例如，Option<T> 遵循相同的模式 - 如果您有 Some(t)，则可以继续沿着愉快的路径前进，而如果您有 None，则希望产生 None 而不是继续。 这种模式扩展到更复杂的类型，例如 Poll<Result<T, E>>，其快乐路径类型是 Poll<T>，这使得 ? 适用的情况比您想象的要多得多。 当 Try 稳定时，我们可能会看到 ? 开始使用各种类型来使我们的快乐路径代码变得更好。

？ 运算符已经可以在易出错的函数、文档测试和 fn main 中使用。 不过，为了充分发挥其潜力，我们还需要一种方法来确定错误处理的范围。 例如，考虑清单 4-2 中的函数。

```
fn do_the_thing() -> Result<(), Error> {
  let thing = Thing::setup()?;
  // .. code that uses thing and ? ..
  thing.cleanup();
  Ok(()) 
} 
```

*Listing 4-2: A multi-step fallible function using the *?* operator*

这不会完全按预期工作。任何 ？设置和清理之间将导致整个函数提前返回，这将跳过清理代码！这就是 *try 块* 旨在解决的问题。 try 块的行为非常类似于单次迭代循环，其中 ?使用break而不是return，并且块的最终表达式有一个隐式的break。现在，我们可以修复清单 4-2 中的代码，使其始终进行清理，如清单 4-3 所示。

```rust
fn do_the_thing() -> Result<(), Error> {
  let thing = Thing::setup()?;
  let r = try {
    // .. code that uses thing and ? ..
  };
  thing.cleanup();
  r
 }
```

*Listing 4-3: A multi-step fallible function that always cleans up after itself* 


在撰写本文时，尝试块也不稳定，但对其有用性已达成足够的共识，它们很可能以类似于此处描述的形式出现。



## Summary

本章介绍了 Rust 中构造错误类型的两种主要方法：枚举和擦除。 我们研究了您何时可能想要使用每一种以及每种的优点和缺点。 我们还了解了一些幕后方面？ 算者又考虑如何？ 未来可能会变得更加有用。 在下一章中，我们将从代码中退一步，看看如何“构建”Rust 项目。 我们将研究功能标志、依赖管理和版本控制，以及如何使用工作区和子包管理更复杂的包。 下一页见！