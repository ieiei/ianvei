当您深入了解 Rust 的更高级部分时，确保对基础知识有充分的了解非常重要。 在 Rust 中，就像在任何编程语言中一样，当您开始以更复杂的方式使用该语言时，各种关键字和概念的精确含义变得很重要。 在本章中，我们将介绍 Rust 的许多原语，并尝试更清楚地定义它们的含义、它们的工作原理以及它们为什么是这样的。 具体来说，我们将研究变量和值的不同之处、它们在内存中的表示方式以及程序具有的不同内存区域。 然后，我们将讨论所有权、借用和生命周期的一些微妙之处，在继续阅读本书之前，您需要掌握这些微妙之处。 如果您愿意，您可以从头到尾阅读本章，也可以将其用作参考来温习您不太确定的概念。 我建议你只有当你感觉完全的时候才继续前进
 
对本章的内容感到满意，因为对这些原语如何工作的误解将很快妨碍理解更高级的主题，或者导致您错误地使用它们。

## 讨论内存

并非所有内存都是一样的。 在大多数编程环境中，您的程序可以访问堆栈、堆、寄存器、文本段、内存映射寄存器、内存映射文件，或许还可以访问非易失性 RAM。 在特定情况下您选择使用哪一个会影响您可以在那里存储什么、可以访问它的时间以及您使用什么机制来访问它。 这些内存区域的具体细节因平台而异，超出了本书的范围，但其中一些对于您如何推理 Rust 代码非常重要，值得在这里介绍。
### 内存术语

在我们深入研究内存区域之前，您首先需要了解值、变量和指针之间的区别。 Rust 中的值是类型和该类型值域的元素的组合。 一个值可以使用其类型的表示形式转换为字节序列，但就其本身而言，您可以认为一个值更像您（程序员）的意思。 例如，类型 u8 中的数字 6 是数学整数 6 的实例，其在内存中的表示形式是字节 0x06。 类似地，str“Hello world”是所有字符串域中的值，其表示形式是其UTF-8编码。 值的含义与存储这些字节的位置无关。

值存储在一个位置，这是 Rust 术语，意思是“可以保存值的位置”。 这个地方可以在栈上，堆上，或者在其他一些地点。 存储值的最常见位置是变量，它是堆栈上的命名值槽。

指针是保存内存区域地址的值，因此指针指向一个位置。 可以取消引用指针以访问存储在其指向的内存位置中的值。 我们可以将同一个指针存储在多个变量中，因此有多个变量间接引用内存中的同一位置，从而引用相同的基础值。

考虑清单 1-1 中的代码，它说明了这三个元素。

---
```
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y;
```
---
*Listing 1-1: Values, variables, and pointers*

这里有四个不同的值：42（i32）、43（i32）、x（指针）的地址和 y（指针）的地址。 还有四个变量：x、y、var1 和 var2。 后两个变量都保存指针类型的值，因为引用是指针。 虽然 var1 和 var2 最初存储相同的值，但它们存储该值的单独、独立的副本； 当我们将 var2 中存储的值更改为 1 时，var1 中的值不会更改。 特别是， = 运算符将右侧表达式的值存储在左侧命名的位置。

变量、值和指针之间的区别变得重要的一个有趣的例子是在如下语句中：

---
```
let string = "Hello world";
```
---

尽管我们将字符串值分配给变量 string，但该变量的实际值是指向字符串值“Hello world”中第一个字符的指针，而不是字符串值本身。 此时您可能会说，“但是等等，那么字符串值存储在哪里？ 指针指向哪里？” 如果是这样，那么您的眼光很敏锐——我们马上就会谈到这一点。

*从技术上讲，字符串的值还包括字符串的长度。 我们将在第 2 章讨论宽指针类型时讨论这一点。*

### 深度变量

我之前给出的变量定义很广泛，而且其本身不太可能有那么大的用处。 当您遇到更复杂的代码时，您将需要更准确的心理模型来帮助您推理程序真正在做什么。 我们可以利用很多这样的模型。 详细描述它们需要几章的时间，超出了本书的范围，但从广义上讲，它们可以分为两类：高层模型和低层模型。 在考虑生命周期和借用级别的代码时，高级模型非常有用，而当您推理不安全代码和原始指针时，低级模型则很有用。 以下两节中描述的变量模型足以满足本书中的大部分内容。

#### 高级模型

在高级模型中，我们不认为变量是保存字节的地方。 相反，我们将它们视为在整个程序中实例化、移动和使用值时赋予值的名称。 当您将值分配给变量时，该值从此由该变量命名。 当稍后访问某个变量时，您可以想象从该变量的先前访问到新访问绘制一条线，这在两个访问之间建立了依赖关系。 如果变量中的值被移动，则无法再从中绘制线条。

在此模型中，变量仅在具有合法值时才存在； 您无法从值未初始化或已移动的变量中绘制线条，因此实际上它不存在。 使用此模型，您的整个程序由许多此类依赖行（通常称为流）组成，每个依赖行都跟踪某个值的特定实例的生命周期。 当存在分支时，流可以分叉和合并，每个分支都跟踪该值的不同生命周期。 编译器可以检查程序中任何给定点，所有可以并行存在的流程是否兼容。 例如，不能存在两个对某个值具有可变访问权限的并行流。 也不可能存在借用值的流，同时不存在拥有该值的流。 清单 1-2 显示了这两种情况的示例。

---
``` rust
let mut x;
// this access would be illegal, nowhere to draw the flow from:
// assert_eq!(x, 42);

x = 42;  
// this is okay, can draw a flow from the value assigned above:

let y = &x;  
// this establishes a second, mutable flow from x:

x = 43;  
// this continues the flow from y, which in turn draws from x. // but that flow conflicts with the assignment to x!

assert_eq!(*y, 42);  
```
---
*Listing 1-2: Illegal flows that the borrow checker will catch*

首先，我们不能在 x 初始化之前使用它，因为我们没有地方可以从中获取流。 只有当我们给 x 赋值时，我们才能从中得出流量。 此代码有两个流：一个从 1 到 3 的独占 (&mut) 流，以及一个从 1 到 2 到 4 的共享 (&) 流。借用检查器检查每个流的每个顶点，并检查是否没有其他不兼容的流同时存在。 在这种情况下，当借用检查器检查 3 处的独占流时，它会看到在 4 处终止的共享流。由于您不能同时对某个值进行独占和共享使用，因此借用检查器（正确地）拒绝 代码。 请注意，如果 4 不存在，则此代码可以正常编译！ 共享流将在 2 处终止，并且当在 3 处检查独占流时，不会存在冲突流。

如果声明的新变量与前一个变量同名，它们仍被视为不同的变量。 这称为遮蔽——后一个变量以相同的名称“遮蔽”前一个变量。 这两个变量共存，尽管后续代码不再能够命名前一个变量。 该模型大致匹配编译器（尤其是借用检查器）关于程序的原因，并且实际上在编译器内部使用以生成高效的代码。

#### 低级模型

变量命名可能包含或不包含合法值的内存位置。 您可以将变量视为“值槽”。 当您分配给它时，该插槽将被填充，并且其旧值（如果有）将被删除并替换。 当您访问它时，编译器会检查该槽是否不为空，因为这意味着该变量未初始化或其值已被移动。 指向变量的指针引用变量的后备内存，并且可以取消引用以获取其值。 例如，在语句 let x: usize 中，变量 x 是堆栈上内存区域的名称，该区域有空间容纳 usize 大小的值，尽管它没有明确定义的值（其槽位） 是空的）。 如果您为该变量分配一个值，例如 x = 6，则该内存区域将保存代表值 6 的位。当您分配给 x 时，&x 不会改变。 如果您声明多个具有相同名称的变量，它们最终仍然会有不同的内存块支持它们。 此模型与 C 和 C++ 以及许多其他低级语言使用的内存模型相匹配，当您需要显式推理内存时非常有用。

*Note. 在此示例中，我们忽略 CPU 寄存器并将其视为优化。 实际上，如果该变量不需要内存地址，则编译器可以使用寄存器来支持变量而不是内存区域。*

您可能会发现其中一个比另一个更符合您之前的模型，但我强烈建议您尝试同时了解它们。 它们都同样有效，而且都是简化，就像任何有用的心智模型一样。 如果您能够从这两个角度考虑一段代码，您会发现更容易处理复杂的代码段并理解它们为什么或不按您的预期编译和工作。